# ToteTracker - GitHub Copilot Development Instructions

## Project Overview

ToteTracker is a comprehensive Flutter storage tracking application built with FlutterFlow that helps users organize and track items in storage containers. The app features AI-powered categorization, QR code scanning, and local SQLite database storage.

### Core Purpose
- Track storage containers and their contents
- AI-powered automatic item categorization using Google Gemini
- QR code integration for container identification
- Local-first approach with SQLite database
- Cross-platform Flutter application (primary focus: Android)

## Architecture & Technology Stack

### Primary Technologies
- **Flutter 3.0+**: Cross-platform mobile framework
- **FlutterFlow**: Visual Flutter development platform (generates base UI components)
- **SQLite**: Local database storage for all app data
- **Google Gemini AI**: Image analysis and automatic categorization
- **Dart**: Primary programming language

### Key Dependencies
- `sqflite`: SQLite database operations
- `flutter_gemini`: Google Gemini AI integration
- `flutter_barcode_scanner`: QR code and barcode scanning
- `image_picker`: Camera and photo selection
- `shared_preferences`: Settings and preferences storage
- `provider`: State management
- `go_router`: Navigation and routing

## Project Structure

```
lib/
├── main.dart                 # App entry point
├── app_state.dart           # Global app state management
├── index.dart               # Export barrel file
├── backend/                 # Data layer
│   ├── schema/             
│   │   └── structs/        # Data structure definitions
│   ├── sqlite/             # SQLite database operations
│   └── api_requests/       # External API integrations
├── pages/                  # UI screens/pages
├── components/             # Reusable UI components
├── custom_code/            # Custom FlutterFlow widgets and actions
│   ├── widgets/           # Custom Flutter widgets
│   └── actions/           # Custom business logic actions
└── flutter_flow/          # FlutterFlow generated components
    ├── flutter_flow_theme.dart    # App theming
    ├── flutter_flow_widgets.dart  # Custom widget helpers
    ├── flutter_flow_model.dart    # Base model classes
    └── nav/               # Navigation configuration
```

## Coding Patterns & Conventions

### Database Operations
- All data is stored locally in SQLite using the `SQLiteManager` class
- Database schemas are defined in `lib/backend/schema/structs/`
- Use struct classes for type-safe data handling
- Follow the existing pattern for CRUD operations

Example database struct pattern:
```dart
class ItemStruct extends BaseStruct {
  ItemStruct({
    String? itemId,
    String? name,
    String? category,
    // ... other fields
  }) : _itemId = itemId,
       _name = name,
       _category = category;

  // Getters and setters with null safety
  String? _itemId;
  String get itemId => _itemId ?? '';
  set itemId(String? val) => _itemId = val;
  bool hasItemId() => _itemId != null;
}
```

### AI Integration Patterns
- Google Gemini integration is handled through `flutter_gemini` package
- AI responses are parsed using custom functions in `lib/flutter_flow/custom_functions.dart`
- Image analysis follows the pattern: capture image → send to AI → parse response → extract name/category

### FlutterFlow Integration
- UI components are primarily generated by FlutterFlow
- Custom widgets extend FlutterFlow base classes
- Theming follows FlutterFlow patterns with `FlutterFlowTheme.of(context)`
- Navigation uses `go_router` with FlutterFlow route definitions

### State Management
- Uses Provider pattern for global state (`FFAppState`)
- Page-specific state managed with FlutterFlow model classes
- Persistent state stored via `shared_preferences`

### Widget Patterns
```dart
// Custom widget pattern
class CustomWidget extends StatefulWidget {
  const CustomWidget({
    Key? key,
    this.width,
    this.height,
    required this.onAction,
  }) : super(key: key);

  final double? width;
  final double? height;
  final Future<dynamic> Function()? onAction;

  @override
  _CustomWidgetState createState() => _CustomWidgetState();
}
```

### Error Handling
- Use try-catch blocks for database operations
- Provide user-friendly error messages
- Log errors for debugging while maintaining user experience
- Graceful degradation when AI features are unavailable

## Domain-Specific Context

### Container Management
- Containers have unique IDs and QR codes
- Containers can contain multiple items
- Support for container metadata (name, description, location, color, size)

### Item Tracking
- Items belong to containers (foreign key relationship)
- Items have names, categories, descriptions, and images
- Images stored as base64 strings in database
- Support for manual and AI-generated categorization

### QR Code Integration
- QR codes identify containers uniquely
- Integration with external QR sticker generator project
- Scanning triggers container selection/creation flow

### AI Features
- Automatic item name generation from images
- Category suggestions based on image analysis
- Fallback to manual entry when AI is unavailable
- Response parsing handles malformed AI responses gracefully

## Development Guidelines

### Adding New Features
1. Follow existing architectural patterns
2. Use FlutterFlow for UI components when possible
3. Implement custom logic in `custom_code/` directory
4. Update database schema in `backend/schema/structs/` if needed
5. Add appropriate error handling and user feedback

### Database Schema Changes
1. Update struct definitions in `backend/schema/structs/`
2. Implement migration logic in `SQLiteManager`
3. Test with existing data to ensure backward compatibility
4. Update related UI components and business logic

### UI Development
1. Leverage FlutterFlow theme system
2. Use consistent spacing and typography
3. Ensure responsive design for different screen sizes
4. Follow Material Design principles
5. Test on actual Android devices

### API Integration
1. Handle network failures gracefully
2. Implement proper error handling for external services
3. Use environment variables for API keys
4. Provide meaningful fallbacks when services are unavailable

## Testing Considerations

### Key Areas to Test
- Database operations (CRUD for containers and items)
- AI integration and response parsing
- QR code scanning functionality
- Image capture and storage
- Data backup and restore functionality
- Navigation between screens
- State persistence across app restarts

### Testing Patterns
- Unit tests for business logic functions
- Widget tests for custom components
- Integration tests for database operations
- Manual testing on Android devices for camera/QR functionality

## Common Gotchas

1. **FlutterFlow Regeneration**: Custom code in `flutter_flow/` directory may be overwritten
2. **Image Storage**: Large images can impact database performance
3. **AI API Limits**: Handle rate limiting and quota exceeded scenarios
4. **QR Code Permissions**: Camera permissions required for scanning
5. **Database Size**: Consider cleanup strategies for large datasets
6. **Offline Usage**: App should work completely offline after initial setup

## Performance Considerations

- Optimize image sizes before database storage
- Implement pagination for large item lists
- Use efficient SQLite queries with proper indexing
- Cache frequently accessed data
- Minimize AI API calls to reduce latency and costs

## Security & Privacy

- All data stored locally (no cloud storage by default)
- API keys should be stored securely
- User consent for camera/storage permissions
- Option to export/backup data maintains user control
- No tracking or analytics without explicit user consent